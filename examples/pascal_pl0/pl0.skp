%% SKP grammar for a reduced version of Pascal based on PL0:
%% http://www.felix-colibri.com/papers/compilers/pl0_grammar/pl0_grammar.html
%%
%%  The __ rule is for 0 or more spaces

ASSIGN    = _"&*s:=&*s" ;
COMMA     = _"&*s,&*s" ;
CLOSEPAR  = _"&*s)&*s" ;
CMP       = _"=\1<>\2<=\3<\4>=\5>\6" #? ;
DOT       = _"&*s.&*s" ;
EOF       = _"&*s&!." ;
EQUAL     = _"&*s=&*s" ;
NAME      = _"&I" ;
NUMBER    = _"&D" ;
OPENPAR   = _"&*s(&*s" ;
SEMICOLON = _"&*s;&*s" ;
STRING    = _"&@'" _"&Q" ;    %% single quoted string but escaped quote is \' not '''
_         = _"&*s" ;

BEGIN     = __ _"&!Cbegin&!@&a" __ ;
CONST     = __ _"&!Cconst&!@&a" __;
DO        = __ _"&!Cdo&!@&a" __ ;
EVEN      = __ _"&!Ceven&!@&a" __;
END       = __ _"&!Cend&!@&a" __;
FUNCTION  = __ _"&!Cfunction&!@&a" __;
IF        = __ _"&!Cif&!@&a" __;
ODD       = __ _"&!Codd&!@&a" __;
PROGRAM   = __ _"&!Cprogram&!@&a" __;
READ      = __ _"&!Cread&!@&a" __ ;
RETURN    = __ _"&!Creturn&!@&a" __;
THEN      = __ _"&!Cthen&!@&a" __ ;
VAR       = __ _"&!Cvar&!@&a" __;
WHILE     = __ _"&!Cwhile&!@&a" __;
WRITE     = __ _"&!Cwrite&!@&a" __ ;

program   = _PROGRAM prog_name (_OPENPAR prog_args _CLOSEPAR)? _block _DOT _EOF ;
prog_name = _NAME ;
prog_args = (__ prog_arg (_COMMA prog_arg )*)?  ;
prog_arg  = _NAME ;

block = decls _statement ;

%% Modified the bnf to make it similar to what Pascal prescribes
decls = _const* _vardef* fndef* ;

const      = _CONST _const_def ( _COMMA  _const_def )* _SEMICOLON ;
const_def  = __ const_name _EQUAL const_val ;
const_name = _NAME ;
const_val  = _NUMBER ;

vardef = _VAR __ vardef_name ( _COMMA vardef_name )* _SEMICOLON ;
vardef_name  = _NAME ;

%% Functions are limited to a single nesting level
fndef = _FUNCTION __ fndef_name _OPENPAR fndef_args _CLOSEPAR _fnblock _SEMICOLON ;
fndef_name = _NAME ;

fndef_args  = (__ fndef_arg (fndef_comma fndef_arg )*)? ;
fndef_arg   = _NAME ;
fndef_comma = _COMMA ;

fnblock = fndecls _statement ;
fndecls = const* vardef*;    %% No embedded functions!

expr   = sign? __ _term ( __ add_op __ _term )* ;
term   = _factor ( __ mult_op __ _factor )* ;

factor = fncall
       / value
       / idref                   %% <-- Can be a variable or a const
       / _OPENPAR expr _CLOSEPAR
       ;

idref  = _NAME ;
value  = _NUMBER ;

fncall = fncall_name _OPENPAR ( fncall_arg (fncall_comma fncall_arg )* )? _CLOSEPAR;
fncall_name  = _NAME ;
fncall_arg   =  expr ;
fncall_comma = _COMMA ;

sign    = _"+\2-\3" ;
add_op  = _"+\2-\3" ;
mult_op = _"*\4/\6" ;

statement = __ (compound_stmt / _simple_stmt) ;

compound_stmt = _BEGIN _statement? (_SEMICOLON _statement )* _END ;

simple_stmt =  write_stmt
            / _read_stmt     %% Not in the original bnf!
            /  if_stmt
            /  while_stmt
            /  return_stmt
            /  fn_stmt
            /  assignment
            ;

fn_stmt = fncall;

if_stmt = _IF condition _THEN _statement;

while_stmt = _WHILE condition _DO _statement ;

return_stmt = _RETURN expr ;

write_stmt = _WRITE ( STRING #?1 / expr ) ;   %% STRING Not in the original bnf!

read_stmt = _READ readvar;
readvar   = _NAME ;

assignment = __ assign_var _ASSIGN expr;
assign_var = _NAME ;

condition = odd_cond / even_cond /expr __ CMP expr ;
odd_cond  = _ODD expr ;
even_cond = _EVEN expr ;
